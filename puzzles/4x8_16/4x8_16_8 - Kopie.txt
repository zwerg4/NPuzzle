def puzzle_from_file(filename):
	"""
	Converts a puzzle file into type ([][], [][]), where the first element of the tuple is the 
	  initial_state and the second is the desired_state.
	Example file:
	2x3          | width x height
	1 2 3 4 0 5  | initial_state
	3 1 2 4 5 0  | desired_state
	"""
Example: "1 2 3 4 0 5" is converted into [[1,2],[3,4],[0,5]] if puzzle dimensions are 2x3

ein Beispiel von uns (4x8_16_8):

8x4
1 2 3 4 0 13 15 7 9 10 11 12 6 5 14 8 17 18 19 20 21 22 23 16 25 26 27 28 29 30 31 24
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 0

d.h., das ist das puzzle:
1   2   3   4   0   13  15  7
9   10  11  12  6   5   14  8
17  18  19  20  21  22  23  16
25  26  27  28  29  30  31  24

jgardner8 lösung:
AS 60
Down;Down;Down;Right;Up;Right;Right;Down;Left;Up;Right;Down;

"händisches" nachvollziehen der lösung:
1   2   3   4   5   6    7  8
9   10  11 12  13  14   15  16
17  18  19  20  21  22  23  24
25  26  27  28  29  30  31  0,

i.e. den desired state
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 0
und damit die richtige lösung.

wenn ich hingegen zeilen und spalten anders herum machen würde, also:
1 2 3 4
0 13 15 7
9 10 11 12
6 5 14 8
17 18 19 20
21 22 23 16
25 26 27 28
29 30 31 24

... dann kann die null nicht in der untersten zeile landen, weil es netto nur 5 - 2 = 3 down-instruktionen gibt.

==> die jgardner8-lsg. stimmt schon

